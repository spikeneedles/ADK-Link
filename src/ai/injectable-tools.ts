/**
 * Injectable Tools Registry
 * 
 * Pre-made utility tools that can be injected into any project.
 * Each tool is a complete, working implementation.
 */

export interface InjectableTool {
  id: string;
  name: string;
  description: string;
  category: 'formatter' | 'generator' | 'utility' | 'testing' | 'database';
  language: 'typescript' | 'python' | 'javascript' | 'rust';
  files: Record<string, string>;
  setupInstructions: string;
  dependencies?: string[];
}

// ==================== CODE FORMATTER TOOL ====================
export const CODE_FORMATTER_TOOL: InjectableTool = {
  id: 'code-formatter',
  name: 'Code Formatter',
  description: 'Multi-language code formatter with configurable rules',
  category: 'formatter',
  language: 'typescript',
  files: {
    'tools/format-code.ts': `#!/usr/bin/env node
/**
 * Code Formatter Tool
 * Formats code files according to language-specific rules
 * Generated by Link - ADK Link
 */

import * as fs from 'fs';
import * as path from 'path';

interface FormatOptions {
  tabSize?: number;
  useTabs?: boolean;
  lineWidth?: number;
}

class CodeFormatter {
  private options: Required<FormatOptions>;

  constructor(options: FormatOptions = {}) {
    this.options = {
      tabSize: options.tabSize ?? 2,
      useTabs: options.useTabs ?? false,
      lineWidth: options.lineWidth ?? 80,
    };
  }

  formatFile(filePath: string): void {
    if (!fs.existsSync(filePath)) {
      console.error(\`File not found: \${filePath}\`);
      return;
    }

    const content = fs.readFileSync(filePath, 'utf-8');
    const ext = path.extname(filePath);
    
    let formatted: string;
    
    switch (ext) {
      case '.ts':
      case '.js':
      case '.tsx':
      case '.jsx':
        formatted = this.formatJavaScript(content);
        break;
      case '.py':
        formatted = this.formatPython(content);
        break;
      case '.rs':
        formatted = this.formatRust(content);
        break;
      default:
        console.log(\`Unsupported file type: \${ext}\`);
        return;
    }

    fs.writeFileSync(filePath, formatted, 'utf-8');
    console.log(\`‚úì Formatted: \${filePath}\`);
  }

  private formatJavaScript(code: string): string {
    // Basic JS/TS formatting
    const lines = code.split('\\n');
    let indentLevel = 0;
    const indent = this.options.useTabs ? '\\t' : ' '.repeat(this.options.tabSize);

    return lines.map(line => {
      const trimmed = line.trim();
      if (!trimmed) return '';

      // Decrease indent for closing braces
      if (trimmed.startsWith('}') || trimmed.startsWith(']') || trimmed.startsWith(')')) {
        indentLevel = Math.max(0, indentLevel - 1);
      }

      const formatted = indent.repeat(indentLevel) + trimmed;

      // Increase indent for opening braces
      if (trimmed.endsWith('{') || trimmed.endsWith('[') || trimmed.endsWith('(')) {
        indentLevel++;
      }

      return formatted;
    }).join('\\n');
  }

  private formatPython(code: string): string {
    // Basic Python formatting (PEP 8 style)
    const lines = code.split('\\n');
    return lines.map(line => {
      // Ensure 4 spaces for Python indentation
      const leadingSpaces = line.match(/^\\s*/)?.[0] ?? '';
      const indentLevel = Math.floor(leadingSpaces.length / 4);
      const content = line.trim();
      return '    '.repeat(indentLevel) + content;
    }).join('\\n');
  }

  private formatRust(code: string): string {
    // Basic Rust formatting
    return this.formatJavaScript(code); // Similar brace style
  }

  formatDirectory(dirPath: string, recursive = true): void {
    const files = fs.readdirSync(dirPath);

    for (const file of files) {
      const fullPath = path.join(dirPath, file);
      const stat = fs.statSync(fullPath);

      if (stat.isDirectory() && recursive) {
        if (!file.startsWith('.') && file !== 'node_modules') {
          this.formatDirectory(fullPath, recursive);
        }
      } else if (stat.isFile()) {
        const ext = path.extname(file);
        if (['.ts', '.js', '.tsx', '.jsx', '.py', '.rs'].includes(ext)) {
          this.formatFile(fullPath);
        }
      }
    }
  }
}

// CLI Usage
if (require.main === module) {
  const args = process.argv.slice(2);
  
  if (args.length === 0) {
    console.log('Usage: npx tsx tools/format-code.ts <file-or-directory>');
    console.log('Example: npx tsx tools/format-code.ts src/');
    process.exit(1);
  }

  const formatter = new CodeFormatter({
    tabSize: 2,
    useTabs: false,
    lineWidth: 80,
  });

  const target = args[0];
  const stat = fs.statSync(target);

  if (stat.isDirectory()) {
    console.log(\`Formatting directory: \${target}\`);
    formatter.formatDirectory(target);
    console.log('‚úì Done!');
  } else {
    formatter.formatFile(target);
  }
}

export { CodeFormatter };`,

    'tools/README-formatter.md': `# Code Formatter Tool

Auto-format your code files with consistent styling.

## Usage

Format a single file:
\`\`\`bash
npx tsx tools/format-code.ts src/index.ts
\`\`\`

Format entire directory:
\`\`\`bash
npx tsx tools/format-code.ts src/
\`\`\`

## Supported Languages

- TypeScript/JavaScript (.ts, .js, .tsx, .jsx)
- Python (.py)
- Rust (.rs)

## Customization

Edit the formatter options in the code:
\`\`\`typescript
const formatter = new CodeFormatter({
  tabSize: 2,        // Spaces per indent
  useTabs: false,    // Use tabs instead of spaces
  lineWidth: 80,     // Max line width
});
\`\`\`
`
  },
  dependencies: ['typescript', 'tsx'],
  setupInstructions: 'Run: npx tsx tools/format-code.ts <file-or-directory>'
};

// ==================== API CLIENT GENERATOR ====================
export const API_CLIENT_GENERATOR: InjectableTool = {
  id: 'api-client-generator',
  name: 'API Client Generator',
  description: 'Generate type-safe API client from OpenAPI/Swagger spec',
  category: 'generator',
  language: 'typescript',
  files: {
    'tools/generate-api-client.ts': `#!/usr/bin/env node
/**
 * API Client Generator
 * Generates type-safe API clients from OpenAPI specs
 * Generated by Link - ADK Link
 */

import * as fs from 'fs';
import * as path from 'path';

interface APISpec {
  paths: Record<string, Record<string, {
    summary?: string;
    parameters?: any[];
    responses?: any;
  }>>;
  components?: {
    schemas?: Record<string, any>;
  };
}

class APIClientGenerator {
  generate(specPath: string, outputPath: string): void {
    console.log(\`Reading OpenAPI spec: \${specPath}\`);
    
    const spec: APISpec = JSON.parse(fs.readFileSync(specPath, 'utf-8'));
    const client = this.buildClient(spec);
    
    fs.writeFileSync(outputPath, client, 'utf-8');
    console.log(\`‚úì Generated API client: \${outputPath}\`);
  }

  private buildClient(spec: APISpec): string {
    let code = \`/**
 * Generated API Client
 * DO NOT EDIT - Generated by Link
 */

export class APIClient {
  private baseURL: string;

  constructor(baseURL: string) {
    this.baseURL = baseURL;
  }

  private async request<T>(
    method: string,
    path: string,
    data?: any
  ): Promise<T> {
    const url = \\\`\\\${this.baseURL}\\\${path}\\\`;
    const options: RequestInit = {
      method,
      headers: { 'Content-Type': 'application/json' },
    };

    if (data) {
      options.body = JSON.stringify(data);
    }

    const response = await fetch(url, options);
    if (!response.ok) {
      throw new Error(\\\`API Error: \\\${response.statusText}\\\`);
    }

    return response.json();
  }
\n\`;

    // Generate methods for each endpoint
    for (const [path, methods] of Object.entries(spec.paths)) {
      for (const [method, details] of Object.entries(methods)) {
        const methodName = this.generateMethodName(method, path);
        const params = this.extractParams(path);
        
        code += \`  async \${methodName}(\${params}): Promise<any> {\n\`;
        code += \`    return this.request('\${method.toUpperCase()}', '\${path}');\n\`;
        code += \`  }\n\n\`;
      }
    }

    code += '}\n';
    return code;
  }

  private generateMethodName(method: string, path: string): string {
    const parts = path.split('/').filter(p => p && !p.startsWith('{'));
    return method + parts.map(p => 
      p.charAt(0).toUpperCase() + p.slice(1)
    ).join('');
  }

  private extractParams(path: string): string {
    const params = path.match(/\\{([^}]+)\\}/g) || [];
    return params.map(p => p.replace(/[{}]/g, '') + ': string').join(', ');
  }
}

// CLI Usage
if (require.main === module) {
  const args = process.argv.slice(2);
  
  if (args.length < 2) {
    console.log('Usage: npx tsx tools/generate-api-client.ts <openapi.json> <output.ts>');
    process.exit(1);
  }

  const generator = new APIClientGenerator();
  generator.generate(args[0], args[1]);
}

export { APIClientGenerator };`,

    'tools/README-api-client.md': `# API Client Generator

Generate type-safe TypeScript clients from OpenAPI/Swagger specs.

## Usage

\`\`\`bash
npx tsx tools/generate-api-client.ts openapi.json src/api-client.ts
\`\`\`

## Example

Given an OpenAPI spec, generates:
\`\`\`typescript
const client = new APIClient('https://api.example.com');
const users = await client.getUsers();
const user = await client.getUserById('123');
\`\`\`
`
  },
  dependencies: ['typescript', 'tsx'],
  setupInstructions: 'Run: npx tsx tools/generate-api-client.ts <openapi.json> <output.ts>'
};

// ==================== UNIT TEST GENERATOR ====================
export const UNIT_TEST_GENERATOR: InjectableTool = {
  id: 'unit-test-generator',
  name: 'Unit Test Generator',
  description: 'Generate test skeletons for functions and classes',
  category: 'testing',
  language: 'typescript',
  files: {
    'tools/generate-tests.ts': `#!/usr/bin/env node
/**
 * Unit Test Generator
 * Generates test skeletons from source files
 * Generated by Link - ADK Link
 */

import * as fs from 'fs';
import * as path from 'path';

class TestGenerator {
  generateTest(sourceFile: string): string {
    const content = fs.readFileSync(sourceFile, 'utf-8');
    const functions = this.extractFunctions(content);
    const classes = this.extractClasses(content);
    
    const basename = path.basename(sourceFile, path.extname(sourceFile));
    
    let testCode = \`import { describe, it, expect } from 'vitest';
import { \${[...functions, ...classes].join(', ')} } from './' + basename + \\\`';

\`;

    // Generate tests for functions
    functions.forEach(fn => {
      testCode += \`describe('\${fn}', () => {
  it('should work correctly', () => {
    // TODO: Implement test
    expect(\${fn}).toBeDefined();
  });

  it('should handle edge cases', () => {
    // TODO: Test edge cases
  });
});

\`;
    });

    // Generate tests for classes
    classes.forEach(cls => {
      testCode += \`describe('\${cls}', () => {
  it('should instantiate correctly', () => {
    const instance = new \${cls}();
    expect(instance).toBeInstanceOf(\${cls});
  });

  it('should have expected methods', () => {
    // TODO: Test methods
  });
});

\`;
    });

    return testCode;
  }

  private extractFunctions(code: string): string[] {
    const functionRegex = /(?:export\\s+)?(?:async\\s+)?function\\s+(\\w+)/g;
    const matches = [];
    let match;
    
    while ((match = functionRegex.exec(code)) !== null) {
      matches.push(match[1]);
    }
    
    return matches;
  }

  private extractClasses(code: string): string[] {
    const classRegex = /(?:export\\s+)?class\\s+(\\w+)/g;
    const matches = [];
    let match;
    
    while ((match = classRegex.exec(code)) !== null) {
      matches.push(match[1]);
    }
    
    return matches;
  }

  generateTestFile(sourceFile: string, outputFile: string): void {
    console.log(\`Generating tests for: \${sourceFile}\`);
    const testCode = this.generateTest(sourceFile);
    fs.writeFileSync(outputFile, testCode, 'utf-8');
    console.log(\`‚úì Generated: \${outputFile}\`);
  }
}

// CLI Usage
if (require.main === module) {
  const args = process.argv.slice(2);
  
  if (args.length === 0) {
    console.log('Usage: npx tsx tools/generate-tests.ts <source-file.ts>');
    process.exit(1);
  }

  const generator = new TestGenerator();
  const sourceFile = args[0];
  const testFile = sourceFile.replace(/\\.ts$/, '.test.ts');
  
  generator.generateTestFile(sourceFile, testFile);
}

export { TestGenerator };`,

    'tools/README-test-generator.md': `# Unit Test Generator

Automatically generate test skeletons for your TypeScript functions and classes.

## Usage

\`\`\`bash
npx tsx tools/generate-tests.ts src/my-module.ts
\`\`\`

Creates \`src/my-module.test.ts\` with test structure.

## Requirements

- Vitest (or adapt for Jest/other test framework)

Install: \`npm install -D vitest\`
`
  },
  dependencies: ['typescript', 'tsx', 'vitest'],
  setupInstructions: 'Run: npx tsx tools/generate-tests.ts <source-file>'
};

// ==================== JSON TO TYPE CONVERTER ====================
export const JSON_TO_TYPE_CONVERTER: InjectableTool = {
  id: 'json-to-type',
  name: 'JSON to Type Converter',
  description: 'Convert JSON to TypeScript interfaces or Python classes',
  category: 'utility',
  language: 'typescript',
  files: {
    'tools/json-to-type.ts': `#!/usr/bin/env node
/**
 * JSON to Type Converter
 * Converts JSON objects to TypeScript types or Python classes
 * Generated by Link - ADK Link
 */

import * as fs from 'fs';

class JSONToTypeConverter {
  convertToTypeScript(json: any, typeName: string = 'Root'): string {
    return \`export interface \${typeName} \${this.objectToTS(json, 0)}\`;
  }

  private objectToTS(obj: any, indent: number): string {
    const spaces = '  '.repeat(indent);
    let result = '{\\n';

    for (const [key, value] of Object.entries(obj)) {
      const type = this.inferType(value);
      result += \`\${spaces}  \${key}: \${type};\\n\`;
    }

    result += spaces + '}';
    return result;
  }

  private inferType(value: any): string {
    if (value === null) return 'null';
    if (Array.isArray(value)) {
      if (value.length === 0) return 'any[]';
      return this.inferType(value[0]) + '[]';
    }
    if (typeof value === 'object') {
      return this.objectToTS(value, 1);
    }
    return typeof value;
  }

  convertToPython(json: any, className: string = 'Root'): string {
    let result = \`from dataclasses import dataclass\\nfrom typing import Optional, List\\n\\n\`;
    result += \`@dataclass\\nclass \${className}:\\n\`;

    for (const [key, value] of Object.entries(json)) {
      const pyType = this.inferPythonType(value);
      result += \`    \${key}: \${pyType}\\n\`;
    }

    return result;
  }

  private inferPythonType(value: any): string {
    if (value === null) return 'Optional[str]';
    if (Array.isArray(value)) return 'List[str]';
    if (typeof value === 'object') return 'dict';
    if (typeof value === 'number') return Number.isInteger(value) ? 'int' : 'float';
    if (typeof value === 'boolean') return 'bool';
    return 'str';
  }
}

// CLI Usage
if (require.main === module) {
  const args = process.argv.slice(2);
  
  if (args.length < 2) {
    console.log('Usage: npx tsx tools/json-to-type.ts <input.json> <ts|py>');
    process.exit(1);
  }

  const converter = new JSONToTypeConverter();
  const json = JSON.parse(fs.readFileSync(args[0], 'utf-8'));
  const format = args[1];

  if (format === 'ts') {
    console.log(converter.convertToTypeScript(json));
  } else if (format === 'py') {
    console.log(converter.convertToPython(json));
  }
}

export { JSONToTypeConverter };`,

    'tools/README-json-to-type.md': `# JSON to Type Converter

Convert JSON objects to TypeScript interfaces or Python dataclasses.

## Usage

TypeScript:
\`\`\`bash
npx tsx tools/json-to-type.ts data.json ts > types.ts
\`\`\`

Python:
\`\`\`bash
npx tsx tools/json-to-type.ts data.json py > models.py
\`\`\`
`
  },
  dependencies: ['typescript', 'tsx'],
  setupInstructions: 'Run: npx tsx tools/json-to-type.ts <input.json> <ts|py>'
};

// ==================== MOCK DATA GENERATOR ====================
export const MOCK_DATA_GENERATOR: InjectableTool = {
  id: 'mock-data-generator',
  name: 'Mock Data Generator',
  description: 'Generate realistic mock data for testing',
  category: 'testing',
  language: 'typescript',
  files: {
    'tools/generate-mock-data.ts': `#!/usr/bin/env node
/**
 * Mock Data Generator
 * Creates realistic mock data for testing
 * Generated by Link - ADK Link
 */

class MockDataGenerator {
  private names = ['Alice', 'Bob', 'Charlie', 'Diana', 'Eve', 'Frank'];
  private domains = ['example.com', 'test.com', 'demo.com'];

  generateUser(id?: number): any {
    const name = this.randomElement(this.names);
    return {
      id: id ?? this.randomId(),
      name,
      email: \`\${name.toLowerCase()}@\${this.randomElement(this.domains)}\`,
      age: this.randomInt(18, 80),
      active: Math.random() > 0.5,
    };
  }

  generateUsers(count: number): any[] {
    return Array.from({ length: count }, (_, i) => this.generateUser(i + 1));
  }

  private randomElement<T>(arr: T[]): T {
    return arr[Math.floor(Math.random() * arr.length)];
  }

  private randomInt(min: number, max: number): number {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  private randomId(): number {
    return Math.floor(Math.random() * 100000);
  }
}

// CLI Usage
if (require.main === module) {
  const args = process.argv.slice(2);
  const count = parseInt(args[0] || '10');

  const generator = new MockDataGenerator();
  const data = generator.generateUsers(count);

  console.log(JSON.stringify(data, null, 2));
}

export { MockDataGenerator };`,

    'tools/README-mock-data.md': `# Mock Data Generator

Generate realistic mock data for testing and development.

## Usage

\`\`\`bash
npx tsx tools/generate-mock-data.ts 50 > mock-users.json
\`\`\`

Generates 50 mock user records.
`
  },
  dependencies: ['typescript', 'tsx'],
  setupInstructions: 'Run: npx tsx tools/generate-mock-data.ts <count>'
};

// ==================== DOCKER CONFIG GENERATOR ====================
export const DOCKER_CONFIG_GENERATOR: InjectableTool = {
  id: 'docker-config',
  name: 'Docker Config Generator',
  description: 'Generate Dockerfile and docker-compose.yml for your project',
  category: 'utility',
  language: 'typescript',
  files: {
    'Dockerfile': `# Multi-stage build for Node.js application
FROM node:20-alpine AS builder

WORKDIR /app

# Copy package files
COPY package*.json ./

# Install dependencies
RUN npm ci

# Copy source code
COPY . .

# Build application
RUN npm run build

# Production stage
FROM node:20-alpine

WORKDIR /app

# Copy package files
COPY package*.json ./

# Install production dependencies only
RUN npm ci --production

# Copy built application from builder
COPY --from=builder /app/dist ./dist

# Create non-root user
RUN addgroup -g 1001 -S nodejs && \\
    adduser -S nodejs -u 1001

USER nodejs

EXPOSE 3000

CMD ["node", "dist/index.js"]`,

    'docker-compose.yml': `version: '3.8'

services:
  app:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "3000:3000"
    environment:
      NODE_ENV: production
      DATABASE_URL: postgresql://postgres:password@db:5432/myapp
    depends_on:
      - db
    restart: unless-stopped

  db:
    image: postgres:16-alpine
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
      POSTGRES_DB: myapp
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    restart: unless-stopped

volumes:
  postgres_data:`,

    '.dockerignore': `node_modules
npm-debug.log
.env
.git
.gitignore
README.md
.vscode
.idea
dist
coverage`,

    'tools/README-docker.md': `# Docker Configuration

Production-ready Docker setup with multi-stage builds.

## Usage

Build and run:
\`\`\`bash
docker-compose up --build
\`\`\`

Development with hot reload:
\`\`\`bash
docker-compose -f docker-compose.dev.yml up
\`\`\`

## Customization

Edit Dockerfile for different:
- Base images (node:20-alpine, python:3.11-slim, etc.)
- Build commands
- Exposed ports
`
  },
  dependencies: [],
  setupInstructions: 'Run: docker-compose up --build'
};

// ==================== GIT HOOKS MANAGER ====================
export const GIT_HOOKS_MANAGER: InjectableTool = {
  id: 'git-hooks',
  name: 'Git Hooks Manager',
  description: 'Pre-commit, pre-push hooks for code quality',
  category: 'utility',
  language: 'typescript',
  files: {
    '.husky/pre-commit': `#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"

echo "üîç Running pre-commit checks..."

# Run linter
npm run lint || {
  echo "‚ùå Linting failed. Fix errors before committing."
  exit 1
}

# Run formatter check
npm run format:check || {
  echo "‚ùå Code formatting issues. Run 'npm run format' to fix."
  exit 1
}

# Run type check
npm run typecheck || {
  echo "‚ùå TypeScript type errors found."
  exit 1
}

echo "‚úÖ Pre-commit checks passed!"`,

    '.husky/pre-push': `#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"

echo "üß™ Running pre-push checks..."

# Run tests
npm run test || {
  echo "‚ùå Tests failed. Fix before pushing."
  exit 1
}

echo "‚úÖ Pre-push checks passed!"`,

    'tools/setup-git-hooks.sh': `#!/bin/bash
# Setup Git Hooks with Husky

echo "üì¶ Installing Husky..."
npm install --save-dev husky

echo "üîß Initializing Husky..."
npx husky install

echo "‚úÖ Git hooks installed!"
echo ""
echo "Add these scripts to package.json:"
echo '  "prepare": "husky install"'
echo '  "lint": "eslint . --ext .ts,.tsx"'
echo '  "format:check": "prettier --check ."'
echo '  "typecheck": "tsc --noEmit"'`,

    'tools/README-git-hooks.md': `# Git Hooks Manager

Automated code quality checks on commit and push.

## Setup

\`\`\`bash
bash tools/setup-git-hooks.sh
\`\`\`

## What It Does

**Pre-commit:**
- Runs linter (ESLint)
- Checks formatting (Prettier)
- Verifies TypeScript types

**Pre-push:**
- Runs full test suite

## Customization

Edit \`.husky/pre-commit\` and \`.husky/pre-push\` to add/remove checks.
`
  },
  dependencies: ['husky'],
  setupInstructions: 'Run: bash tools/setup-git-hooks.sh'
};

// ==================== ENV GENERATOR ====================
export const ENV_GENERATOR: InjectableTool = {
  id: 'env-generator',
  name: 'Environment Config Generator',
  description: 'Generate .env templates and type-safe config loaders',
  category: 'utility',
  language: 'typescript',
  files: {
    '.env.example': `# Database
DATABASE_URL=postgresql://user:password@localhost:5432/myapp

# API Keys
API_KEY=your_api_key_here
SECRET_KEY=your_secret_key_here

# Application
NODE_ENV=development
PORT=3000

# External Services
REDIS_URL=redis://localhost:6379
EMAIL_HOST=smtp.example.com
EMAIL_PORT=587`,

    'src/config/env.ts': `/**
 * Type-safe environment configuration
 * Generated by Link - ADK Link
 */

import * as dotenv from 'dotenv';
dotenv.config();

interface EnvironmentConfig {
  database: {
    url: string;
  };
  api: {
    key: string;
    secretKey: string;
  };
  app: {
    nodeEnv: 'development' | 'production' | 'test';
    port: number;
  };
  services: {
    redisUrl: string;
    emailHost: string;
    emailPort: number;
  };
}

function getEnvVar(key: string, defaultValue?: string): string {
  const value = process.env[key] || defaultValue;
  if (!value) {
    throw new Error(\`Missing required environment variable: \${key}\`);
  }
  return value;
}

export const env: EnvironmentConfig = {
  database: {
    url: getEnvVar('DATABASE_URL'),
  },
  api: {
    key: getEnvVar('API_KEY'),
    secretKey: getEnvVar('SECRET_KEY'),
  },
  app: {
    nodeEnv: getEnvVar('NODE_ENV', 'development') as any,
    port: parseInt(getEnvVar('PORT', '3000')),
  },
  services: {
    redisUrl: getEnvVar('REDIS_URL', 'redis://localhost:6379'),
    emailHost: getEnvVar('EMAIL_HOST'),
    emailPort: parseInt(getEnvVar('EMAIL_PORT', '587')),
  },
};

// Validate on load
console.log('‚úì Environment configuration loaded');`,

    'tools/README-env.md': `# Environment Configuration

Type-safe environment variable management.

## Setup

1. Copy example file:
\`\`\`bash
cp .env.example .env
\`\`\`

2. Fill in your values in \`.env\`

3. Import config:
\`\`\`typescript
import { env } from './src/config/env';

console.log(env.database.url);
console.log(env.api.key);
\`\`\`

## Features

- Type-safe access
- Required vs optional variables
- Default values
- Validation on startup
`
  },
  dependencies: ['dotenv'],
  setupInstructions: 'Copy .env.example to .env and fill in values'
};

// ==================== ESLINT CONFIG ====================
export const ESLINT_CONFIG: InjectableTool = {
  id: 'eslint-config',
  name: 'ESLint Configuration',
  description: 'Production-ready ESLint setup for TypeScript',
  category: 'formatter',
  language: 'typescript',
  files: {
    '.eslintrc.json': `{
  "parser": "@typescript-eslint/parser",
  "parserOptions": {
    "ecmaVersion": 2022,
    "sourceType": "module",
    "project": "./tsconfig.json"
  },
  "extends": [
    "eslint:recommended",
    "plugin:@typescript-eslint/recommended",
    "plugin:@typescript-eslint/recommended-requiring-type-checking"
  ],
  "plugins": ["@typescript-eslint"],
  "rules": {
    "@typescript-eslint/no-unused-vars": ["error", { "argsIgnorePattern": "^_" }],
    "@typescript-eslint/explicit-function-return-type": "off",
    "@typescript-eslint/no-explicit-any": "warn",
    "no-console": ["warn", { "allow": ["warn", "error"] }]
  },
  "ignorePatterns": ["dist/", "node_modules/", "*.config.js"]
}`,

    '.prettierrc': `{
  "semi": true,
  "trailingComma": "es5",
  "singleQuote": true,
  "printWidth": 100,
  "tabWidth": 2
}`,

    '.eslintignore': `node_modules
dist
build
coverage
*.config.js`,

    'tools/README-eslint.md': `# ESLint Configuration

Strict TypeScript linting for production code quality.

## Setup

Install dependencies:
\`\`\`bash
npm install -D eslint @typescript-eslint/parser @typescript-eslint/eslint-plugin prettier
\`\`\`

Add scripts to package.json:
\`\`\`json
{
  "scripts": {
    "lint": "eslint . --ext .ts,.tsx",
    "lint:fix": "eslint . --ext .ts,.tsx --fix",
    "format": "prettier --write .",
    "format:check": "prettier --check ."
  }
}
\`\`\`

## Usage

\`\`\`bash
npm run lint
npm run lint:fix
npm run format
\`\`\`
`
  },
  dependencies: ['eslint', '@typescript-eslint/parser', '@typescript-eslint/eslint-plugin', 'prettier'],
  setupInstructions: 'Install deps and run: npm run lint'
};

// ==================== GITHUB ACTIONS CI ====================
export const GITHUB_ACTIONS_CI: InjectableTool = {
  id: 'github-actions-ci',
  name: 'GitHub Actions CI/CD',
  description: 'Complete CI/CD pipeline with tests, linting, and deployment',
  category: 'utility',
  language: 'typescript',
  files: {
    '.github/workflows/ci.yml': `name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        node-version: [18.x, 20.x]
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Use Node.js \${{ matrix.node-version }}
      uses: actions/setup-node@v4
      with:
        node-version: \${{ matrix.node-version }}
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Run linter
      run: npm run lint
    
    - name: Run type check
      run: npm run typecheck
    
    - name: Run tests
      run: npm test
    
    - name: Build
      run: npm run build

  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Deploy to production
      run: |
        echo "üöÄ Deploying to production..."
        # Add your deployment commands here`,

    '.github/workflows/release.yml': `name: Release

on:
  push:
    tags:
      - 'v*'

jobs:
  release:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Use Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20.x'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Build
      run: npm run build
    
    - name: Create Release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: \${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: \${{ github.ref }}
        release_name: Release \${{ github.ref }}
        draft: false
        prerelease: false`,

    'tools/README-github-actions.md': `# GitHub Actions CI/CD

Automated testing, linting, and deployment on every push.

## What It Does

**On every push/PR:**
- Runs tests on Node 18 & 20
- Lints code with ESLint
- Type checks with TypeScript
- Builds the project

**On push to main:**
- Deploys to production

**On version tags (v*):**
- Creates GitHub release

## Customization

Edit \`.github/workflows/ci.yml\` to add:
- Database testing
- E2E tests
- Code coverage
- Security scanning
`
  },
  dependencies: [],
  setupInstructions: 'Commit to GitHub - workflows run automatically'
};

// ==================== ZOD VALIDATION SCHEMAS ====================
export const ZOD_SCHEMAS: InjectableTool = {
  id: 'zod-schemas',
  name: 'Zod Validation Schemas',
  description: 'Type-safe validation schemas with Zod',
  category: 'utility',
  language: 'typescript',
  files: {
    'src/schemas/user.schema.ts': `/**
 * User validation schemas
 * Generated by Link - ADK Link
 */

import { z } from 'zod';

export const UserSchema = z.object({
  id: z.string().uuid(),
  email: z.string().email('Invalid email format'),
  name: z.string().min(2, 'Name must be at least 2 characters'),
  age: z.number().int().positive().optional(),
  role: z.enum(['admin', 'user', 'guest']).default('user'),
  createdAt: z.date().or(z.string().datetime()),
});

export const CreateUserSchema = UserSchema.omit({ id: true, createdAt: true });
export const UpdateUserSchema = UserSchema.partial().omit({ id: true });

export type User = z.infer<typeof UserSchema>;
export type CreateUser = z.infer<typeof CreateUserSchema>;
export type UpdateUser = z.infer<typeof UpdateUserSchema>;

// Validation helper
export function validateUser(data: unknown): User {
  return UserSchema.parse(data);
}`,

    'src/schemas/api.schema.ts': `/**
 * API request/response schemas
 * Generated by Link - ADK Link
 */

import { z } from 'zod';

export const PaginationSchema = z.object({
  page: z.number().int().positive().default(1),
  limit: z.number().int().positive().max(100).default(20),
  sort: z.enum(['asc', 'desc']).default('asc'),
});

export const ApiResponseSchema = z.object({
  success: z.boolean(),
  data: z.any(),
  error: z.string().optional(),
  meta: z.object({
    timestamp: z.string().datetime(),
    version: z.string(),
  }).optional(),
});

export type Pagination = z.infer<typeof PaginationSchema>;
export type ApiResponse = z.infer<typeof ApiResponseSchema>;`,

    'tools/README-zod.md': `# Zod Validation Schemas

Type-safe runtime validation with Zod.

## Setup

\`\`\`bash
npm install zod
\`\`\`

## Usage

\`\`\`typescript
import { validateUser, CreateUserSchema } from './src/schemas/user.schema';

// Validate data
const user = validateUser(rawData);

// API route validation
app.post('/users', async (req, res) => {
  try {
    const data = CreateUserSchema.parse(req.body);
    // data is type-safe!
  } catch (error) {
    res.status(400).json({ error: 'Validation failed' });
  }
});
\`\`\`

## Add More Schemas

Create new files in \`src/schemas/\` for:
- Products
- Orders
- Posts
- etc.
`
  },
  dependencies: ['zod'],
  setupInstructions: 'Install zod: npm install zod'
};

// ==================== ERROR HANDLER ====================
export const ERROR_HANDLER: InjectableTool = {
  id: 'error-handler',
  name: 'Error Handler & Logger',
  description: 'Centralized error handling and structured logging',
  category: 'utility',
  language: 'typescript',
  files: {
    'src/utils/error-handler.ts': `/**
 * Centralized Error Handler
 * Generated by Link - ADK Link
 */

export class AppError extends Error {
  constructor(
    public message: string,
    public statusCode: number = 500,
    public isOperational: boolean = true
  ) {
    super(message);
    this.name = this.constructor.name;
    Error.captureStackTrace(this, this.constructor);
  }
}

export class ValidationError extends AppError {
  constructor(message: string) {
    super(message, 400);
  }
}

export class NotFoundError extends AppError {
  constructor(resource: string) {
    super(\`\${resource} not found\`, 404);
  }
}

export class UnauthorizedError extends AppError {
  constructor(message: string = 'Unauthorized') {
    super(message, 401);
  }
}

// Express error middleware
export function errorMiddleware(err: Error, req: any, res: any, next: any) {
  if (err instanceof AppError) {
    return res.status(err.statusCode).json({
      success: false,
      error: err.message,
      ...(process.env.NODE_ENV === 'development' && { stack: err.stack }),
    });
  }

  // Unknown error
  console.error('üí• UNHANDLED ERROR:', err);
  return res.status(500).json({
    success: false,
    error: 'Internal server error',
  });
}`,

    'src/utils/logger.ts': `/**
 * Structured Logger
 * Generated by Link - ADK Link
 */

enum LogLevel {
  DEBUG = 'debug',
  INFO = 'info',
  WARN = 'warn',
  ERROR = 'error',
}

class Logger {
  private context: string;

  constructor(context: string) {
    this.context = context;
  }

  private log(level: LogLevel, message: string, meta?: any) {
    const timestamp = new Date().toISOString();
    const logEntry = {
      timestamp,
      level,
      context: this.context,
      message,
      ...meta,
    };

    const emoji = {
      [LogLevel.DEBUG]: 'üîç',
      [LogLevel.INFO]: '‚ÑπÔ∏è',
      [LogLevel.WARN]: '‚ö†Ô∏è',
      [LogLevel.ERROR]: '‚ùå',
    };

    console.log(\`\${emoji[level]} [\${level.toUpperCase()}] [\${this.context}] \${message}\`, meta || '');
  }

  debug(message: string, meta?: any) {
    this.log(LogLevel.DEBUG, message, meta);
  }

  info(message: string, meta?: any) {
    this.log(LogLevel.INFO, message, meta);
  }

  warn(message: string, meta?: any) {
    this.log(LogLevel.WARN, message, meta);
  }

  error(message: string, error?: Error, meta?: any) {
    this.log(LogLevel.ERROR, message, { ...meta, error: error?.message, stack: error?.stack });
  }
}

export function createLogger(context: string): Logger {
  return new Logger(context);
}`,

    'tools/README-error-handler.md': `# Error Handler & Logger

Centralized error handling and structured logging.

## Usage

**Error Handling:**
\`\`\`typescript
import { NotFoundError, ValidationError, errorMiddleware } from './src/utils/error-handler';

// Throw typed errors
throw new NotFoundError('User');
throw new ValidationError('Invalid email');

// Express middleware
app.use(errorMiddleware);
\`\`\`

**Logging:**
\`\`\`typescript
import { createLogger } from './src/utils/logger';

const logger = createLogger('UserService');

logger.info('User created', { userId: '123' });
logger.error('Failed to create user', error);
\`\`\`
`
  },
  dependencies: [],
  setupInstructions: 'Import and use in your application'
};

// ==================== TOOLS REGISTRY ====================
export const ALL_INJECTABLE_TOOLS: InjectableTool[] = [
  CODE_FORMATTER_TOOL,
  API_CLIENT_GENERATOR,
  UNIT_TEST_GENERATOR,
  JSON_TO_TYPE_CONVERTER,
  MOCK_DATA_GENERATOR,
  DOCKER_CONFIG_GENERATOR,
  GIT_HOOKS_MANAGER,
  ENV_GENERATOR,
  ESLINT_CONFIG,
  GITHUB_ACTIONS_CI,
  ZOD_SCHEMAS,
  ERROR_HANDLER,
];

/**
 * Get tool by ID
 */
export function getToolById(id: string): InjectableTool | undefined {
  return ALL_INJECTABLE_TOOLS.find(t => t.id === id);
}

/**
 * Find tools by category
 */
export function getToolsByCategory(category: string): InjectableTool[] {
  return ALL_INJECTABLE_TOOLS.filter(t => t.category === category);
}
